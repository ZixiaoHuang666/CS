# LC 1438 longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit

![image-20210423173236349](C:\Users\ZiXiao Huang\AppData\Roaming\Typora\typora-user-images\image-20210423173236349.png)

## Pre-thinking

这道题，首先是怎么找到子数组，然后保证子数组内任意元素组合绝对值小于target，子数组的个数是一个等差数列，n方级别，枚举所有组合又是n方怎么化简？

首先如果选出子数组可以通过排序从n方-nlogn

怎么找子数组呢，只有两种情况要么，是从自己开始另起炉灶，要么是承接上一个元素，但是子问题不在独立，因为要考虑新进元素可能会破坏老元素之间的关系，不再满足，再加进去之前先判断是否能和老元素相处融洽这个方法是可以的，因为老的长度是连在一起的不可能能够变得更长，仔细一想发现还是不行，因为到这一位最长也可能比之前的位数少，只和几个老元素融洽这种情况被忽略了，子问题不独立，应该是不能使用dp的，怎么办呢

数据集大小10的5次方，只能O(N) O(NLOGN)

暴力解决必然是不可能的，涉及到多个数，并且是连续，并要要求时间复杂度非常低，可以基本得出结论滑动，那怎么滑动呢，我们发现我们可以通过维护一个最大值和最小值，这样就能直接判断新加入的元素是否在这个范围内，如果在范围内右指针贪心扩张，如果在范围外，左指针回缩，重置最大最小值，直到可以加入右边元素，如果所有元素收完了重置最大最小值为Integer.max min O(n)时间





